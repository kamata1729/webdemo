<!DOCTYPE html>
<html lang="en">
<head>
    <title>Text-to-Texture Demo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
    <script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three/build/three.module.js"
				}
			}
    </script>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'https://unpkg.com/three@0.158.0/examples/jsm/loaders/GLTFLoader.js';
        import { OBJLoader } from 'https://unpkg.com/three@0.158.0/examples/jsm/loaders/OBJLoader.js';
        import { RGBELoader } from 'https://unpkg.com/three@0.158.0/examples/jsm/loaders/RGBELoader.js';
        import { MTLLoader } from 'https://unpkg.com/three@0.158.0/examples/jsm/loaders/MTLLoader.js';

        let camera, scene, renderer, controls;
        let currentModelIndex = 0;
        const models = [
        { path: 'models/louis_vuitton/', obj: 'output.obj', mtl: 'output.mtl' },
        { path: 'models/candy/', obj: 'output.obj', mtl: 'output.mtl' },
        ];

        init();
        

        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);
        
            // カメラの設定
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 20);
            camera.position.set(-1.8, 0.6, 2.7);
        
            // シーンの設定
            scene = new THREE.Scene();

            loadModel(currentModelIndex);
            
            // 環境テクスチャのローダー
            new RGBELoader()
                .setPath('textures/equirectangular/')
                .load('royal_esplanade_1k.hdr', function (texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.background = texture;
                    scene.environment = texture;
                    render(); // テクスチャ読み込み後にレンダリング
                });
            
            // 環境光源を作成
            const ambientLight = new THREE.AmbientLight(0xffffff);
            ambientLight.intensity = 3;
            scene.add(ambientLight);

            // 平行光源を作成
            const directionalLight = new THREE.DirectionalLight(0xffffff);
            directionalLight.intensity = 3;
            directionalLight.position.set(1, 3, 1);
            scene.add(directionalLight);

            // レンダラーの設定
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1;
            container.appendChild(renderer.domElement);

            // コントロールの設定
            controls = new OrbitControls(camera, renderer.domElement);
            controls.addEventListener('change', render); // アニメーションループがない場合はこれを使用
            controls.minDistance = 2;
            controls.maxDistance = 10;
            controls.target.set(0, 0, -0.2);
            controls.update();

            // リサイズイベントのハンドラーを設定
            window.addEventListener('resize', onWindowResize);

            // ボタンのイベントリスナーを追加
            document.querySelector('.button-next').addEventListener('click', function () {
                changeModel(1); // 次のモデルへ
            });

            document.querySelector('.button-previous').addEventListener('click', function () {
                changeModel(-1); // 前のモデルへ
            });
        }

        function loadModel(index) {
            // 配列の範囲チェック
            if (index < 0 || index >= models.length) {
                console.error('Index out of bounds');
                return;
            }

            // モデル情報を取得
            const modelInfo = models[index];

            // シーンから以前のメッシュをクリア
            for (let i = scene.children.length - 1; i >= 0; i--) {
                const obj = scene.children[i];
                if (obj.isMesh) {
                    // メッシュのマテリアルとジオメトリの解放
                    if (obj.geometry) {
                        obj.geometry.dispose();
                    }
                    if (obj.material) {
                        if (obj.material.isMaterial) {
                            cleanMaterial(obj.material);
                        } else {
                            // マテリアルが配列の場合
                            for (const material of obj.material) {
                                cleanMaterial(material);
                            }
                        }
                    }
                    scene.remove(obj);
                }
            }

            // MTLLoaderを設定
            const mtlLoader = new MTLLoader().setPath(modelInfo.path);
            mtlLoader.load(modelInfo.mtl, function (materials) {
                materials.preload();

                // OBJLoaderを設定
                const objLoader = new OBJLoader().setMaterials(materials).setPath(modelInfo.path);
                objLoader.load(modelInfo.obj, function (object) {

                    // モデルにトラバースして、各メッシュのマテリアルを設定
                    object.traverse(function (child) {
                        if (child.isMesh) {
                            child.material.envMap = scene.environment; // 環境マップを設定
                            child.material.metalness = 0;
                            child.material.roughness = 1;
                        }
                    });

                    // オブジェクトをシーンに追加
                    scene.add(object);

                    // カメラの位置とコントロールズを更新
                    updateCameraPosition(object);

                    // シーンを再レンダリング
                    render();
                }, onProgress, onError);
            });
        }

        function cleanMaterial(material) {
            material.dispose();
            // テクスチャがあれば解放
            if (material.map) material.map.dispose();
            if (material.lightMap) material.lightMap.dispose();
            if (material.bumpMap) material.bumpMap.dispose();
            if (material.normalMap) material.normalMap.dispose();
            if (material.specularMap) material.specularMap.dispose();
            if (material.envMap) material.envMap.dispose();
            // その他のマップも同様に解放
        }


        /*function loadModel(index) {
            // 配列の範囲チェック
            if (index < 0 || index >= models.length) {
                console.error('Index out of bounds');
                return;
            }
        
            // モデル情報を取得
            const modelInfo = models[index];
            console.log(modelInfo)
        
            // シーンから以前のモデルをクリア
            while (scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
        
            // MTLLoaderを設定
            const mtlLoader = new MTLLoader().setPath(modelInfo.path);
            mtlLoader.load(modelInfo.mtl, function (materials) {
                materials.preload();
        
                // OBJLoaderを設定
                const objLoader = new OBJLoader().setMaterials(materials).setPath(modelInfo.path);
                objLoader.load(modelInfo.obj, function (object) {
        
                    // モデルにトラバースして、各メッシュのマテリアルを設定
                    object.traverse(function (child) {
                        if (child.isMesh) {
                            child.material.metalness = 0.5;
                            child.material.roughness = 0.5;
                        }
                    });
        
                    // オブジェクトをシーンに追加
                    scene.add(object);
        
                    // カメラの位置とコントロールズを更新
                    updateCameraPosition(object);
        
                    // シーンを再レンダリング
                    render();
                }, onProgress, onError);
            });
        }*/

        function changeModel(direction) {
            currentModelIndex = (currentModelIndex + direction + models.length) % models.length;
            loadModel(currentModelIndex);
        }
        
        function updateCameraPosition(object) {
            // オブジェクトのバウンディングボックスを計算してカメラの位置を更新
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 4 * Math.tan(fov * 2));
            cameraZ *= 1.25;
            camera.position.z = cameraZ;
        
            controls.target.set(center.x, center.y, center.z);
            controls.update();
        }

        function render() {
            renderer.render(scene, camera);
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        }

        function onProgress(xhr) {
            if (xhr.lengthComputable) {
                const percentComplete = xhr.loaded / xhr.total * 100;
                console.log('model ' + Math.round(percentComplete, 2) + '% downloaded');
            }
        }
        
        function onError(err) {
            console.error(err);
        }

    </script>

    <div class="button-container">
        <button class="button-previous" role="button">Previous</button>
        <button class="button-next" role="button">Next</button> 
    </div>
</body>
</html>

